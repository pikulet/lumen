{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/triple-semaphore","result":{"data":{"markdownRemark":{"id":"fdf1822e-2a5d-5eb2-a4d0-0cb085b072d9","html":"<p>While working on a synchronisation problem, I came across a quick fix online that basically used three semaphores. However, I was subsequently unable to find this source again so I thought I’d document it here.</p>\n<p>Basically, semaphores are synchronisation primitives used to protect a critical section of code. The idea is that only a controlled number of processes (usually 1) can enter the critical section. Usually, this involves some kind of modification of data and multiple threads executing the section simultaneously could lead to a <strong>race condition</strong>. An analogy would be a class of students shouting their names at the same time. In the end, the teacher almost got nothing out of it.</p>\n<p>Binary semaphores work by have a process <code class=\"language-text\">wait</code> to indicate that it is in the critical section, and <code class=\"language-text\">signal</code> to indicate that it is done being in the CS.</p>\n<p>Suppose we have a semaphore N, and two processes A and B. Each of A and B would run like this:</p>\n<ul>\n<li><code class=\"language-text\">wait(N)</code></li>\n<li><strong>Execute critical section code</strong></li>\n<li><code class=\"language-text\">signal(N)</code></li>\n</ul>\n<p>When either process A or B calls <code class=\"language-text\">wait</code> on the semaphore, the other process is <strong>blocked</strong> at the <code class=\"language-text\">wait</code> until the process in the critical section releases the semaphore using <code class=\"language-text\">signal</code>. Now, there are numerous classical problems already detailing the problems that arise from using synchronisation involving waiting, such as deadlocks and livelocks. This will not be the focus of this blog post.</p>\n<h3 id=\"priority-in-semaphores\" style=\"position:relative;\"><a href=\"#priority-in-semaphores\" aria-label=\"priority in semaphores permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Priority in Semaphores</h3>\n<p>Suppose I have 10 processes running the same program as A, and another 10 processes running the same program as B. When all these 20 processes run, the semaphore grants access to any process that is blocked at <code class=\"language-text\">wait</code> - that is, there is no queue or priority being set.</p>\n<p>Example:</p>\n<ul>\n<li>A1 is in the critical section, and A2, B1 and B2 are blocked at <code class=\"language-text\">wait(N)</code>.</li>\n<li>There is no guarantee of which process will enter the critical section after A1 calls <code class=\"language-text\">signal</code>.</li>\n</ul>\n<p>How can we give processes of type B to be given priority access to the semaphore?</p>\n<h2 id=\"solution\" style=\"position:relative;\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h2>\n<p>This is a 3-semaphore solution.</p>\n<ul>\n<li>Semaphore N, the original semaphore as above</li>\n<li>Semaphore H, a semaphore for high-priority access</li>\n<li>Semaphore L, a semaphore for low-priority access</li>\n</ul>\n<p>Then, the following works as a priority gate to filter between A and B.</p>\n<p>Type B (high priority):</p>\n<ul>\n<li><code class=\"language-text\">wait(H)</code></li>\n<li><code class=\"language-text\">wait(N)</code></li>\n<li><code class=\"language-text\">signal(H)</code></li>\n<li><strong>Execute critical section code</strong></li>\n<li><code class=\"language-text\">signal(N)</code></li>\n</ul>\n<p>Type A (low priority):</p>\n<ul>\n<li><code class=\"language-text\">wait(L)</code></li>\n<li><code class=\"language-text\">wait(H)</code></li>\n<li><code class=\"language-text\">wait(N)</code></li>\n<li><code class=\"language-text\">signal(H)</code></li>\n<li><strong>Execute critical section code</strong></li>\n<li><code class=\"language-text\">signal(N)</code></li>\n<li><code class=\"language-text\">signal(L)</code></li>\n</ul>\n<p>In particular, at most one low-priority process can be blocked at <code class=\"language-text\">wait(H)</code> because of <code class=\"language-text\">wait(L)</code>. However, this doesn’t guarantee that high-priority processes can always run before low-priority processes. The actual behaviour depends on thread-level scheduling. If the scheduler always lets processes of type A (low priority) run first, then there would be no priority access achieved.</p>\n<p>The high-priority semaphore is actually optional. With just L and N, the code is essentially the turnstile problem with writer priority :)</p>","fields":{"slug":"/posts/triple-semaphore","tagSlugs":["/tag/synchronisation/"]},"frontmatter":{"date":"2019-12-30","description":"Quick fix for priority access to a semaphore","tags":["synchronisation"],"title":"Synchronisation using Semaphores"}}},"pageContext":{"slug":"/posts/triple-semaphore"}},"staticQueryHashes":["251939775","3439816877","401334301"]}