{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/tcp-traceroute","result":{"data":{"markdownRemark":{"id":"f46b15d5-1e8e-5289-9bfa-989097297b96","html":"<h3 id=\"traceroute\" style=\"position:relative;\"><a href=\"#traceroute\" aria-label=\"traceroute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traceroute?</h3>\n<p>Traceroute is a program used to determine the route that packets take from your computer to a destination. Most UNIX systems come with a default traceroute program.</p>\n<p>Usually, traceroute is implemented over UDP. Packets are sent with an increasing time-to-live (TTL) value in the IP header. When the TTL expires, an ICMP error message is sent back to the host. Information on the intermediate hops is extracted from these ICMP error messages.</p>\n<p>To detect when the destination has been reached, the UDP message is actually sent to a random, unused port (e.g. 10293). Since the port has no service running, an ICMP port unreachable error is sent back to the host.</p>\n<h3 id=\"why-implement-traceroute-using-tcp\" style=\"position:relative;\"><a href=\"#why-implement-traceroute-using-tcp\" aria-label=\"why implement traceroute using tcp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why implement traceroute using TCP?</h3>\n<p>Some hosts have firewalls that disable UDP messages, as most applications running over HTTP also use TCP.</p>\n<h3 id=\"tcp-traceroute-mechanism\" style=\"position:relative;\"><a href=\"#tcp-traceroute-mechanism\" aria-label=\"tcp traceroute mechanism permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP traceroute mechanism</h3>\n<p>The TCP traceroute mechanism is also error-based. The expiring TTL mechanism is used to detect the intermediate hops. Interestingly, probing packet is a TCP SYN packet, which is used to start a TCP 3-way handshake. The packet is also sent to an unused port which is not interested in starting a 3-way handshake. </p>\n<p>Two scenarios can arise, the port can return an ICMP port unreachable error. However, it is more common to encounter the TCP RST packet. These RST packets are used when an unpected TCP packet arrives at a host</p>\n<h3 id=\"implementation-in-c\" style=\"position:relative;\"><a href=\"#implementation-in-c\" aria-label=\"implementation in c permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Implementation in C</h3>\n<p>A raw socket can be used to send the TCP messages. The SYN flag should be set. A tricky problem with using raw sockets is that the TCP checksum has to be manually configured. </p>\n<p>I found out about the use of pseudoheaders in calculating TCP checksums. Basically, part of the information in the IP header is actually included within this pseudoheader. Additionally, each time the TTL is reconfigured, the IP checksum has to be recalculated.</p>\n<p>Using raw sockets and pseudoheaders is really complicated. That’s when my classmate proposed using TCP sockets (<code class=\"language-text\">SOCK_STREAM</code>). The <code class=\"language-text\">connect()</code> routine automatically triggers a TCP SYN packet to be sent!</p>\n<p>However, one must also account for the probing packets that never return. This timeout can be checked using <code class=\"language-text\">setsockopt()</code>.</p>\n<p>Lastly, I put everything together by running <code class=\"language-text\">connect()</code>. Once the function returns or a timeout is triggered, I can check the <code class=\"language-text\">errno</code> being set. Some examples of the <code class=\"language-text\">errno</code> values that could occur:</p>\n<ul>\n<li><code class=\"language-text\">EHOSTUNREACH</code>: an ICMP error has been received. Probably an intermediate host, but could be the final destination`.</li>\n<li><code class=\"language-text\">ETIMEDOUT</code>: a timeout has occurred</li>\n<li><code class=\"language-text\">EINPROGRESS</code>, EALREADY: a timeout has occurred, could be consecutive timeouts</li>\n<li><code class=\"language-text\">ECONNRESET</code>: The TCP RST packet; the final destination has been reached</li>\n<li><code class=\"language-text\">ECONNREFUSED</code>: The final destination has been reached</li>\n</ul>\n<h4 id=\"remarks\" style=\"position:relative;\"><a href=\"#remarks\" aria-label=\"remarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Remarks</h4>\n<p>This project has been a great way to understand about socket programming. It’s very fulfilling to have built a traceroute in TCP, albeit simplified. Socket programming is fundamental in writing network applications, and I hope to work with it more in future.</p>\n<p>The traceroute program can be found <a href=\"https://github.com/pikulet/tcptrace\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.</p>","fields":{"slug":"/posts/tcp-traceroute","tagSlugs":["/tag/traceroute/","/tag/tcp/"]},"frontmatter":{"date":"2019-10-01","description":"A hacky way to implement traceroute","tags":["traceroute","tcp"],"title":"Traceroute using TCP"}}},"pageContext":{"slug":"/posts/tcp-traceroute"}},"staticQueryHashes":["251939775","3439816877","401334301"]}