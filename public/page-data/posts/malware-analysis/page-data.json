{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/malware-analysis","result":{"data":{"markdownRemark":{"id":"d3426103-7d84-53f1-950a-53bba22de2c5","html":"<p>During my internship at DSO National Laboratories, I worked on binaries in Windows OS. I’d like to share some of the interesting things that came up during the project.</p>\n<h3 id=\"portable-executable-pe-files\" style=\"position:relative;\"><a href=\"#portable-executable-pe-files\" aria-label=\"portable executable pe files permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Portable Executable (PE) Files</h3>\n<p>PE files are basically <code class=\"language-text\">.exe</code> or <code class=\"language-text\">.dll</code> (library) files in the Windows OS. In Linux, the equivalent would be <code class=\"language-text\">ELF</code>. In order to understand the malware behaviour, we had to learn about PE file formats (such as the DOS stubs, sections, and most importantly the import table).</p>\n<p>You can do interesting things by manipulating file formats, and this is known as <a href=\"https://www.youtube.com/watch?v=-0DEEbQq8jU\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PE malformation</a>.</p>\n<h3 id=\"packer-detection\" style=\"position:relative;\"><a href=\"#packer-detection\" aria-label=\"packer detection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packer Detection</h3>\n<p>Most malware are packed. Packed files basically look like encrypted files, but they are self-running (i.e. self-unpacking). On the other hand, encrypted files need some decryption keys.</p>\n<p>Since these files are self-unpacking, the unpacking code is not packed. Files packed with the same algorithm (e.g. UPX) would have a very similar unpacking algorithm. Then, these unpacking algorithm can be used to identify malware.</p>\n<p>I looked at how packer detection tools work and the patterns that they detect. Most common packer detection tools use a simple byte string matching (with wildcards). It then becomes possible to do assembly-level changes to the instructions that can change the byte string without affecting the behaviour. </p>\n<p>For example,</p>\n<ul>\n<li>Swapping the position of two instructions with no dependencies</li>\n<li>Replacing instructions that have the same effect (e.g. <code class=\"language-text\">test eax, eax</code> and <code class=\"language-text\">or eax, eax</code>, both set the <code class=\"language-text\">Z</code> flag which is used by a succeeding <code class=\"language-text\">je</code> instruction)</li>\n</ul>\n<p>These patterns can be automatically generated, which would benefit both the malware authors and analysts. On one hand, malware authors can basically generate variants of the code, hoping one of them will not be detected. On the other hand, malware analysts can generate variants of the code to more comprehensively detect these small changes made to the packed file.</p>\n<h3 id=\"anti-debugging\" style=\"position:relative;\"><a href=\"#anti-debugging\" aria-label=\"anti debugging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Anti-Debugging</h3>\n<p>Debuggers are often used to break apart the inner workings of malware. The suite of techniques used to counter debuggers are known as anti-debugging techniques. These techniques can be classified into 3 categories:</p>\n<p><strong>Debugger detection</strong>: detect the prescence of debuggers, and terminate the program if a debugger is present.</p>\n<ul>\n<li><code class=\"language-text\">IsDebuggerPresent</code>: A Windows API call that returns the <code class=\"language-text\">BeingDebugged</code> flag in the <code class=\"language-text\">Process Environment Block (PEB)</code></li>\n<li><code class=\"language-text\">FindWindow</code>: A Windows API call that checks for the name of window handlers</li>\n<li><code class=\"language-text\">OutputDebugString</code>: An exception-based method; without a debugger, this method is expected to raise an exception</li>\n<li><code class=\"language-text\">SeDebugPrivilege</code>: Checks for <code class=\"language-text\">SE_DEBUG_PRIVILEGE</code> in the process token. This privilege is only open to processes in elevated mode (“run as administrator”), such as debuggers</li>\n<li><code class=\"language-text\">OpenCsrss</code>: Indirectly checks for <code class=\"language-text\">SE_DEBUG_PRIVILEGE</code>, as the <code class=\"language-text\">Client/ Server Runtime Subsystem</code> process can only be accessed by privileged processes</li>\n</ul>\n<p><strong>Anti-Attaching</strong>: each process can only have one debugger invasively attached to it. The idea then, is to spawn your own child process that debugs the parent process.</p>\n<ul>\n<li>Of course, analysts can detach the debugger via kernel debugging</li>\n</ul>\n<p><strong>Anti-Dumping</strong>: Dumping executables in common in reconstructing import tables in packed files. To thwart this process, the <code class=\"language-text\">SizeOfImage</code> in the PE file can be modified, so the dumping tool does not work properly.</p>\n<h3 id=\"remarks\" style=\"position:relative;\"><a href=\"#remarks\" aria-label=\"remarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Remarks</h3>\n<ul>\n<li>Packing is actually a legitimate tool used to limit reverse-engineering. Think of Android APK files, they are difficult to reverse engineer to protect the intellectual property of developers.</li>\n<li>Most of the techniques have operating system-specific behaviour (e.g. Windows XP vs. Windows 7 vs. Windows 10), which I studied in detail.</li>\n</ul>\n<p>For a full report, do refer <a href=\"/malware-analysis-report.pdf\">here</a>. I also made a short presentation <a href=\"/malware-analysis-ppt.pdf\">here</a>.</p>","fields":{"slug":"/posts/malware-analysis","tagSlugs":["/tag/malware-analysis/","/tag/reverse-engineering/"]},"frontmatter":{"date":"2019-08-02","description":"A study of Anti-Reverse Engineering techniques used by malware","tags":["malware analysis","reverse engineering"],"title":"Malware Analysis - How do malware evade analysis?"}}},"pageContext":{"slug":"/posts/malware-analysis"}},"staticQueryHashes":["251939775","3439816877","401334301"]}