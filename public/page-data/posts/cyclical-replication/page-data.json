{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/cyclical-replication","result":{"data":{"markdownRemark":{"id":"2c492df3-bffe-5d06-93d7-11e180da8757","html":"<p>Most database clusters follow the one master multiple slaves architecture. Writes only happen to the master, while reads can happen between the master and slave.</p>\n<p>However, a multi-master application can be beneficial in cases where we have partitional writes to the database. This means that <code class=\"language-text\">id=1-10</code> are primarily written to by one group of functions, while <code class=\"language-text\">id=2-20</code> are written by another. Allowing multiple write sources is beneficial to improve performance. Another reason could be a large geographical separation in the write sources - having a write source in each continent would increase its local performance.</p>\n<h2 id=\"cyclical-replication\" style=\"position:relative;\"><a href=\"#cyclical-replication\" aria-label=\"cyclical replication permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cyclical replication</h2>\n<p>In a multi-master scenario, <code class=\"language-text\">A</code> is listening to transactions from <code class=\"language-text\">B</code> and vice versa. Suppose that <code class=\"language-text\">A</code> executes a transaction (<code class=\"language-text\">tx</code>) and <code class=\"language-text\">B</code> copies this transaction from <code class=\"language-text\">A</code> (<code class=\"language-text\">tx_copy</code>). Now, because <code class=\"language-text\">A</code> is also listening to <code class=\"language-text\">B</code>, <code class=\"language-text\">A</code> will attempt to replicate the <code class=\"language-text\">tx_copy</code> transaction. <code class=\"language-text\">A</code> needs to be able to detect that <code class=\"language-text\">tx_copy</code> is a copied transaction.</p>\n<h2 id=\"binlog-based-detection\" style=\"position:relative;\"><a href=\"#binlog-based-detection\" aria-label=\"binlog based detection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binlog-based detection</h2>\n<p>We can let <code class=\"language-text\">A</code> detect this loop by having <code class=\"language-text\">B</code> insert a dummy statement in the transaction.</p>\n<p>Initially, the structure of a transaction is like this:</p>\n<ul>\n<li><code class=\"language-text\">BEGIN</code></li>\n<li><code class=\"language-text\">STMT</code></li>\n<li><code class=\"language-text\">COMMIT</code></li>\n</ul>\n<p>A dummy statement can be inserted. For instance, we might insert the dummy statement after <code class=\"language-text\">BEGIN</code> so that the pipeline can simply ignore all future messages.</p>\n<ul>\n<li><code class=\"language-text\">BEGIN</code></li>\n<li><code class=\"language-text\">dummy</code> (inserted)</li>\n<li><code class=\"language-text\">STMT</code></li>\n<li><code class=\"language-text\">COMMIT</code></li>\n</ul>\n<h4 id=\"update-statement\" style=\"position:relative;\"><a href=\"#update-statement\" aria-label=\"update statement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UPDATE statement</h4>\n<p>The goal of the dummy statement is to generate binlog traffic without impacting the actual operations. We might want to save resources by opting to use a command like <code class=\"language-text\">UPDATE</code> instead of <code class=\"language-text\">INSERT</code>. </p>\n<p>In a high-concurrency setting, the updates cannot have the <code class=\"language-text\">WHERE</code> clause, because we do not know the previous value of the dummy column. The final statement might look like <code class=\"language-text\">UPDATE table SET dummy_col = x</code>. To ensure that there is real binlog traffic generated, the <code class=\"language-text\">x</code> value cannot be the same as the existing value of the column. </p>\n<p>In other words, if two transactions could occur concurrently, we need to ensure that the <code class=\"language-text\">x</code> value is always different. While we can keep track of a pool of possible <code class=\"language-text\">x</code> values, a transaction can use, we can also opt for a sequential addition. Overflows do not matter since by the time the <code class=\"language-text\">x</code> value cycles back to <code class=\"language-text\">1</code> (for unsigned int), the previous transaction would already have been replicated.</p>\n<p>This solution works. While an update statement does not create significant load on the underlying database engine, it still causes a real transaction to be executed.</p>\n<h4 id=\"blackhole-engine\" style=\"position:relative;\"><a href=\"#blackhole-engine\" aria-label=\"blackhole engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Blackhole engine</h4>\n<p>Another alternative might be to consider using a blackhole (no-op) engine. When creating the table, add <code class=\"language-text\">engine = blackhole</code>.</p>\n<p>However, upon testing, mysql enforces a separate transaction on statements to blackhole tables. The transaction ends up being split up:</p>\n<ul>\n<li><code class=\"language-text\">BEGIN</code></li>\n<li><code class=\"language-text\">dummy</code></li>\n<li><code class=\"language-text\">COMMIT</code></li>\n<li><code class=\"language-text\">BEGIN</code></li>\n<li><code class=\"language-text\">STMT</code></li>\n<li><code class=\"language-text\">COMMIT</code></li>\n</ul>\n<p>We now have two transactions, that need to be executed one after the other. However, this is not efficient in a high-concurrency setting. We would have to lock the other threads to ensure this sequence of events occurs. However, this solution is viable for a single-thread scenario.</p>\n<h4 id=\"drop-view-if-exists\" style=\"position:relative;\"><a href=\"#drop-view-if-exists\" aria-label=\"drop view if exists permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DROP VIEW IF EXISTS</h4>\n<p>An interesting alternative to the blackhole engine is to use <code class=\"language-text\">DROP VIEW IF EXISTS x</code>. It generates a binlog statement without having any real operation. This idea came from <a href=\"https://github.com/openark/orchestrator/blob/master/docs/configuration-discovery-pseudo-gtid.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">openark/orchestrator</a> using <code class=\"language-text\">DROP VIEW</code> to inject GTIDs for engines without such support.</p>\n<p>However, because <code class=\"language-text\">DROP VIEW</code> is a DDL (data definition language) event, it will also be put in a separate transaction like blackhole engine statements. As such, this method is also not viable for multi-thread settings.</p>\n<h2 id=\"uuid-based-detection\" style=\"position:relative;\"><a href=\"#uuid-based-detection\" aria-label=\"uuid based detection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UUID-based detection</h2>\n<p>Binlog-based detection has its pitfalls, since it fundamentally generates additional network traffic. Another method is to use the GTID (Global Transaction ID) of a transaction to detect its source.</p>\n<p>The GTID is of the format:\n<code class=\"language-text\">&lt;server_uuid>:&lt;seq_no></code></p>\n<p>When <code class=\"language-text\">A</code> executes a transaction to <code class=\"language-text\">B</code> (<code class=\"language-text\">tx</code>), <code class=\"language-text\">tx</code> will have a GTID like <code class=\"language-text\">uuid_A:1</code>. Upon receiving this transaction, <code class=\"language-text\">B</code> can detect that the <code class=\"language-text\">server_uuid</code> portion of the GTID is not its own. <code class=\"language-text\">B</code> will then replicate <code class=\"language-text\">tx</code> to get <code class=\"language-text\">tx_copy</code>.</p>\n<h4 id=\"set-gtid_next\" style=\"position:relative;\"><a href=\"#set-gtid_next\" aria-label=\"set gtid_next permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SET gtid_next</h4>\n<p>Since we’re programatically doing this replication, <code class=\"language-text\">B</code> is not actually in the same database cluster as <code class=\"language-text\">A</code>. <code class=\"language-text\">tx_copy</code> will have a GTID like <code class=\"language-text\">uuid_B:1</code>. When <code class=\"language-text\">A</code> receives this transaction, the behaviour is to (incorrectly) replicate it.</p>\n<p>To solve this, we can use an operation like <code class=\"language-text\">set gtid_next</code> to overwrite <code class=\"language-text\">B</code>’s default transaction behaviour. Instead of writing to the binlog with <code class=\"language-text\">uuid_B:1</code>, B can execute <code class=\"language-text\">tx</code> with GTID <code class=\"language-text\">uuid_A:1</code>. </p>\n<p>When <code class=\"language-text\">A</code> receives this transaction and sees its own uuid, it can then ignore the transaction.</p>\n<h4 id=\"multiple-uuids-in-the-cluster\" style=\"position:relative;\"><a href=\"#multiple-uuids-in-the-cluster\" aria-label=\"multiple uuids in the cluster permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multiple UUIDs in the cluster</h4>\n<p>In reality, <code class=\"language-text\">A</code> cannot just hold the logic to drop transactions with its own uuid. This is because <code class=\"language-text\">A</code> is in a database cluster with <code class=\"language-text\">A_slave</code>. In the event of a failover, <code class=\"language-text\">A_slave</code> would be the acting master instead of <code class=\"language-text\">A</code>. The transactions from <code class=\"language-text\">B</code> would have the form <code class=\"language-text\">uuid_A_slave:2</code>. This means that <code class=\"language-text\">A</code> has to know the UUIDs of all slaves in its cluster at the point of replication.</p>\n<p>It is challenging to start the replication process with all known UUIDs in the cluster. During a failover or server restart, the UUID is generated again. There could be <code class=\"language-text\">uuid_A_old</code> in the mix of transactions.</p>\n<p>To overcome this, a metadata server is needed to remember all UUIDs that were ever taken up by the cluster. The UUID can also be manually set to follow a pattern e.g. clusterA always starts with <code class=\"language-text\">11111111</code> in the UUID. However, this manual operation is prone to human errors. It only takes one database instance to be created without following the operating procedure to break the UUID management. A metadata server is more foolproof, though also more complex to implement.</p>","fields":{"slug":"/posts/cyclical-replication","tagSlugs":["/tag/database/"]},"frontmatter":{"date":"2022-02-10","description":"Multi-master database replication","tags":["database"],"title":"Cyclical transaction-based replication"}}},"pageContext":{"slug":"/posts/cyclical-replication"}},"staticQueryHashes":["251939775","3439816877","401334301"]}