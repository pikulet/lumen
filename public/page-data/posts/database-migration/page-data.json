{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/database-migration","result":{"data":{"markdownRemark":{"id":"85ff6f07-216d-54ed-9012-cf770ce44acf","html":"<p>Most software engineers are familiar with database migrations. There are a plethora of readily-available tools to perform migrations, at just the click of a button. This article delves into some topics and concepts about database migrations.</p>\n<h2 id=\"what-is-database-migration\" style=\"position:relative;\"><a href=\"#what-is-database-migration\" aria-label=\"what is database migration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is Database Migration</h2>\n<p>Suppose that your application is currently using a database, but it encounters increasing write pressure, e.g. due to an increasing user base. At this time, the database administrator might recommend <strong>sharding</strong> the database.</p>\n<p>The most straightforward method to migrate a database is to stop all writes to the database, then copy all the data over to the new one. Once that copy process has concluded, then the application can continue writing to the database. </p>\n<p>However, this <strong>offline migration</strong> is problematic in real-time applications that cannot afford to simply stop writing to a database. The database might be very large, and the migration process could be in the order of days.</p>\n<p>More often that not, applications would prefer to carry out <strong>online migration</strong>, where the database has no downtime.</p>\n<h2 id=\"types-of-database-migration\" style=\"position:relative;\"><a href=\"#types-of-database-migration\" aria-label=\"types of database migration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Types of Database Migration</h2>\n<p>First, I’ll give an overview of how database migration are commonly performed. There are two main types of migration, namely scan-based and binlog-based.</p>\n<ul>\n<li><strong>Scan-based</strong> migration: read from the old database (<code class=\"language-text\">SELECT</code>), and then write to the new database.</li>\n<li><strong>Binlog-based</strong> replication: read an event from the binary log (binlog), and then replicate that event to the new database. </li>\n</ul>\n<p>Binlog replication is used in master-slave replication. Each time the application writes to the database master, the slave reads the change and copies it. Reading the change is more efficient that scanning the entire database to copy what is different. </p>\n<p>However, applications can have a large number of change events. In that case, it is not feasible to store those changes for a long period of time. An expiry date is attached to binlog files.</p>\n<h2 id=\"why-both-techniques-are-needed-in-online-migration\" style=\"position:relative;\"><a href=\"#why-both-techniques-are-needed-in-online-migration\" aria-label=\"why both techniques are needed in online migration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why both techniques are needed in Online Migration</h2>\n<p>Now we can delve into the intricacies of online migration.</p>\n<p>First, let’s have a database with a lot of data, and some data was written a long time ago. Most of the binlogs would have already expired, so scan-based migration is needed. We also let the migration process read the rows in order, from primary key <code class=\"language-text\">1</code>, to <code class=\"language-text\">2</code> and so on, up to a million.</p>\n<p>Remember that during this process of scanning and copying the million rows (which might take 3 days), the database is still online. The application continues to write to the database. </p>\n<h4 id=\"scan-before-write\" style=\"position:relative;\"><a href=\"#scan-before-write\" aria-label=\"scan before write permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scan before Write</h4>\n<p>Suppose that the row <code class=\"language-text\">id=1</code> has been scan-copied to the new database. At this time, the application modifies the row <code class=\"language-text\">id=1</code>. The migration process needs to ensure that the new data for <code class=\"language-text\">id=1</code> can be copied over to the new database. It can do so by referring to the binlogs and there would be no issues with this case.</p>\n<h2 id=\"data-inconsistency-in-online-migration\" style=\"position:relative;\"><a href=\"#data-inconsistency-in-online-migration\" aria-label=\"data inconsistency in online migration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Inconsistency in Online Migration</h2>\n<p>Next, I’ll talk about a data inconsistency that can occur when we mix scan-based migration and binlog-based replication.</p>\n<h4 id=\"write-before-scan---data-inconsistency\" style=\"position:relative;\"><a href=\"#write-before-scan---data-inconsistency\" aria-label=\"write before scan   data inconsistency permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Write before Scan - data inconsistency</h4>\n<p>However, we also need to consider that writes can occur before scans. The application modifies the row <code class=\"language-text\">id=30000</code> before the scan process has copied <code class=\"language-text\">id=30000</code> over. If we follow the chronological order of events, there’s a need to <strong>wait</strong> for the scan process before the write. Else, the migration process first deletes the row in the new database, before the scan process incorrectly inserts the row again.</p>\n<p>However, waiting for the scan to complete is not viable. The binlog could expire during the process of waiting for the scan the complete. </p>\n<p>We can counter this expiry by keeping all the binlog files in-memory, but that would contradict why the files had to expire in the first place. In real-time systems, these files are simply very <strong>LARGE</strong>.</p>\n<h2 id=\"further-reading\" style=\"position:relative;\"><a href=\"#further-reading\" aria-label=\"further reading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Further Reading</h2>\n<p>Different systems have their own techniques to cover these pitfalls of database migration, one of which being the more well-known <a href=\"https://github.com/github/gh-ost\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gh-ost</a> by Github.</p>\n<p>There is also a more detailed article about these concepts by Google that comes in <a href=\"https://cloud.google.com/architecture/database-migration-concepts-principles-part-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Part 1</a> and <a href=\"https://cloud.google.com/architecture/database-migration-concepts-principles-part-2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Part 2</a>.</p>","fields":{"slug":"/posts/database-migration","tagSlugs":["/tag/database/"]},"frontmatter":{"date":"2021-10-18","description":"Beyond the click of a button","tags":["database"],"title":"Database Migration"}}},"pageContext":{"slug":"/posts/database-migration"}},"staticQueryHashes":["251939775","3439816877","401334301"]}